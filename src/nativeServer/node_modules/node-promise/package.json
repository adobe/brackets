{
  "name": "node-promise",
  "description": "Kris Zyp's implementation of promises with added features, maintained as an npm package.",
  "version": "0.5.6",
  "homepage": "https://github.com/MaxMotovilov/node-promise",
  "files": [
    "package.json",
    "promise.js",
    "fs-promise.js"
  ],
  "main": "promise.js",
  "repository": {
    "type": "git",
    "url": "https://MaxMotovilov@github.com/MaxMotovilov/node-promise.git"
  },
  "readme": "MIT License.\n\nThe node-promise project provides a complete promise implementation. Promises provide a clean separation\nof concerns between asynchronous behavior and the interface so asynchronous\nfunctions can be called without callbacks, and callback interaction can be \ndone on the generic promise interface. The node-promise package provides just a promise implementation, however, https://github.com/kriszyp/promised-io is recommended for more complete promise-based IO functionality. The promised-io includes the promise implementation from node-promise, as well as wrappers around Node's filesystem and other system I/O APIs for consistent promise-based interaction.\n\nThe node-promise module features a promise implementation with:\n\n* Chainable promises\n* Promises throw errors if an error handler is not provided\n* CommonJS promise proposal [1] compliant\n* Immutable once fulfilled to reduce possible side-effects\n* Promises can be used securely (as separate resolver/promise pairs in\nocap situations)\n* Backwards compatibility where possible (addCallback, addErrback,\nemitSuccess, and emitError should still behave as expected)\n\nUtility functions, including:\n\n* when() - Normalization of sync (normal values) and async (promises)\n* all() - Create a promise that accumulate multiple concurrent promises (failed promises resolve to Error objects)\n* allOrNone() - Ditto, but the first promise to fail causes the composition to fail as well\n* first() - Find the first promise to be fulfilled in a group of promises\n* seq() - Sequentially execute a set of promise returning functions\n* delay() - Returns a promise that is fulfilled after a given amount of time\n* execute() - Executes a function that takes a callback and returns a\npromise (thank you Benjamin Thomas for providing this)\n\nMuch of this is adapted from Tyler Close's ref_send and Kris Kowal's work on promises. \n\nSome quick examples from test-promise.js (again, it is recommended that you use http://github.com/kriszyp/promised-io for file and other I/O interaction):\n    util = require('util');\n    var fs = require('./fs-promise');\n\n    // open a file and read it\n    fs.open(\"fs-promise.js\", process.O_RDONLY).then(function(fd){\n      return fs.read(fd, 4096);\n    }).then(function(args){\n      util.puts(args[0]); // print the contents of the file\n    });\n\n    // does the same thing\n    fs.readFile(\"fs-promise.js\").addCallback(util.puts);\n\nA default Promise constructor can be used to create a self-resolving deferred/promise:\n\n    var Promise = require(\"promise\").Promise;\n    var promise = new Promise();\n    asyncOperation(function(){\n      Promise.resolve(\"succesful result\");\n    });\n    promise -> given to the consumer\n \nA consumer can use the promise:\n\n    promise.then(function(result){\n       ... when the action is complete this is executed ...\n    },\n    function(error){\n        ... executed when the promise fails\n    });\n\nAlternately, a provider can create a deferred and resolve it when it completes an action. \nThe deferred object a promise object that provides a separation of consumer and producer to protect\npromises from being fulfilled by untrusted code.\n\n    var defer = require(\"promise\").defer;\n    var deferred = defer();\n    asyncOperation(function(){\n      deferred.resolve(\"succesful result\");\n    });\n    deferred.promise -> given to the consumer\n \nAnother way that a consumer can use promises:\n\n    var when = require(\"promise\").when;\n    when(promise,function(result){\n       ... when the action is complete this is executed ...\n    },\n    function(error){\n       ... executed when the promise fails\n    });\n\nMore examples:\n\n    function printFirstAndList(itemsDeferred){\n      findFirst(itemsDeferred).then(util.puts);\n      findLast(itemsDeferred).then(util.puts);\n    }\n    function findFirst(itemsDeferred){\n      return itemsDeferred.then(function(items){\n        return items[0];\n      });\n    }\n    function findLast(itemsDeferred){\n      return itemsDeferred.then(function(items){\n        return items[items.length];\n      });\n    }\n\nAnd now you can do:\n\n    printFirstAndLast(someAsyncFunction());\n\n\nThe workhorse function of this library is the \"when\" function, which provides a means for normalizing interaction with values and functions that may be a normal synchronous value, or may be a promise (asynchronously fulfilled). The when() function takes a value that may be a promise or a normal value for the first function, and when the value is ready executes the function provided as the second argument (immediately in the case of a non-promise normal value). The value returned from when() is the result of the execution of the provided function, and returns a promise if provided a promise or synchronously returns a normal value if provided a non-promise value. This makes it easy to \"chain\" computations together. This allows us to write code that is agnostic to sync/async interfaces:\n\n    var when = require(\"promise\").when;\n    function printFirstAndLast(items){\n      // print the first and last item\n      when(findFirst(items), util.puts);\n      when(findLast(items), util.puts);\n    }\n    function findFirst(items){\n       // return the first item\n       return when(items, function(items){\n         return items[0];\n       });\n    }\n    function findLast(items){\n       // return the last item\n       return when(items, function(items){\n         return items[items.length - 1];\n       });\n    }\n\nNow we can do:\n\n    > printFirstAndLast([1,2,3,4,5]);\n    1\n    5\n\nAnd we can also provide asynchronous promise:\n\n    var promise = new process.Promise();\n    > printFirstAndLast(promise);\n\n(nothing printed yet)\n\n    > promise.emitSuccess([2,4,6,8,10]);\n    2\n    10\n\n\nThe \"all\" function is intended to provide a means for waiting for the completion of an array of promises. The \"all\" function should be passed an array of promises, and it returns an promise that is fulfilled once all the promises in the array are fulfilled. The returned promise's resolved value will be an array with the resolved values of all of the promises in the passed in array.\n\nThe \"first\" function is intended to provide a means for waiting for the completion of the first promise in an array of promises to be fulfilled. The \"first\" function should be passed an array of promises, and it returns an promise that is fulfilled once the first promise in the array is fulfilled. The returned promise's resolved value will be the resolved value of the first fulfilled promise.\n\n",
  "readmeFilename": "README.md",
  "_id": "node-promise@0.5.6",
  "dist": {
    "shasum": "b155b0076328ec9f5e9f899ddf7ac0231e6fe19d"
  },
  "_from": "node-promise@~ 0.5.2",
  "_resolved": "https://registry.npmjs.org/node-promise/-/node-promise-0.5.6.tgz"
}
