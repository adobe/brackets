{
  "name": "bluebird",
  "description": "Full featured Promises/A+ implementation with exceptionally good performance",
  "version": "0.9.7-0",
  "keywords": [
    "promise",
    "performance",
    "fast",
    "promises-aplus",
    "async"
  ],
  "scripts": {
    "test": "grunt test"
  },
  "homepage": "https://github.com/petkaantonov/bluebird",
  "repository": {
    "type": "git",
    "url": "git://github.com/petkaantonov/bluebird.git"
  },
  "bugs": {
    "url": "http://github.com/petkaantonov/bluebird/issues"
  },
  "license": "MIT",
  "author": {
    "name": "Petka Antonov",
    "email": "petka_antonov@hotmail.com",
    "url": "http://github.com/petkaantonov/"
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-jshint": "~0.6.4",
    "grunt-contrib-watch": "~0.5.3",
    "grunt-contrib-concat": "~0.3.0",
    "promises-aplus-tests": "~1.3.2",
    "acorn": "~0.3.1",
    "grunt-bump": "0.0.11",
    "mocha": "~1.12.1",
    "q": "~0.9.7",
    "when": "~2.4.0",
    "deferred": "~0.6.5",
    "rsvp": "~2.0.4",
    "avow": "~2.0.1",
    "jsdom": "~0.8.4",
    "jquery-browserify": "~1.8.1",
    "closure-compiler": "~0.2.1",
    "sinon": "~1.7.3",
    "kew": "~0.2.2",
    "browserify": "~2.35.0",
    "concurrent": "~0.3.2",
    "text-table": "~0.2.0"
  },
  "readmeFilename": "README.md",
  "main": "./js/main/bluebird.js",
  "readme": "<a href=\"http://promisesaplus.com/\">\r\n    <img src=\"http://promisesaplus.com/assets/logo-small.png\" alt=\"Promises/A+ logo\"\r\n         title=\"Promises/A+ 1.0 compliant\" align=\"right\" />\r\n</a>\r\n\r\n#Introduction\r\n\r\nBluebird is a fully featured [promise](#what-are-promises-and-why-should-i-use-them) library with focus on innovative features and performance.\r\n\r\n#Topics\r\n\r\n- [Features](#features)\r\n- [Quick start](#quick-start)\r\n- [API Reference and examples](https://github.com/petkaantonov/bluebird/blob/master/API.md)\r\n- [What are promises and why should I use them?](#what-are-promises-and-why-should-i-use-them)\r\n- [Error handling](#error-handling)\r\n- [Development](#development)\r\n    - [Testing](#testing)\r\n    - [Benchmarking](#benchmarks)\r\n    - [Custom builds](#custom-builds)\r\n- [What is the sync build?](#what-is-the-sync-build)\r\n- [License](#license)\r\n- [Snippets for common problems](https://github.com/petkaantonov/bluebird/wiki/Snippets)\r\n- [Promise anti-patterns](https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns)\r\n- [Changelog](https://github.com/petkaantonov/bluebird/blob/master/changelog.md)\r\n\r\n#Features:\r\n\r\n- [Promises A+ 3.x.x](https://github.com/promises-aplus/promises-spec)\r\n- [Promises A+ 2.x.x](https://github.com/domenic/promises-unwrapping)\r\n- [Cancellation](https://github.com/promises-aplus)\r\n- [Progression](https://github.com/promises-aplus/progress-spec)\r\n- [Synchronous inspection](https://github.com/promises-aplus/synchronous-inspection-spec)\r\n- [`.bind`](https://github.com/petkaantonov/bluebird/blob/master/API.md#binddynamic-thisarg---promise)\r\n- [Complete parallel for C# 5.0 async and await](https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutinegeneratorfunction-generatorfunction---function)\r\n- [Collection methods](https://github.com/petkaantonov/bluebird/blob/master/API.md#collections) such as All, any, some, settle, map, filter, reduce, spread, join...\r\n- [Practical debugging solutions](#error-handling) such as unhandled rejection reporting, typed catches, catching only what you expect and very long, relevant stack traces without losing perf\r\n- [Sick performance](https://github.com/petkaantonov/bluebird/tree/master/benchmark/stats)\r\n\r\nPasses [AP2](https://github.com/petkaantonov/bluebird/tree/master/test/mocha), [AP3](https://github.com/petkaantonov/bluebird/tree/master/test/mocha), [Cancellation](https://github.com/petkaantonov/bluebird/blob/master/test/mocha/cancel.js), [Progress](https://github.com/petkaantonov/bluebird/blob/master/test/mocha/q_progress.js), [promises_unwrapping](https://github.com/petkaantonov/bluebird/blob/master/test/mocha/promises_unwrapping.js) (Just in time thenables), [Q](https://github.com/petkaantonov/bluebird/tree/master/test/mocha) and [When.js](https://github.com/petkaantonov/bluebird/tree/master/test) tests. See [testing](#testing).\r\n\r\n<hr>\r\n\r\n#Quick start\r\n\r\n##Node.js\r\n\r\n    npm install bluebird\r\n\r\n\r\nThen:\r\n\r\n```js\r\nvar Promise = require(\"bluebird\");\r\n```\r\n\r\nIf you want to ensure you get your own fresh copy of bluebird, do instead:\r\n\r\n```js\r\n                                        //Note the extra function call\r\nvar Promise = require(\"bluebird/js/main/promise\")();\r\n```\r\n\r\n##Browsers\r\n\r\nDownload the [bluebird.js](https://github.com/petkaantonov/bluebird/tree/master/js/browser) file. And then use a script tag:\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"/scripts/bluebird.js\"></script>\r\n```\r\n\r\nThe global variable `Promise` becomes available after the above script tag.\r\n\r\nAfter quick start, see [API Reference and examples](https://github.com/petkaantonov/bluebird/blob/master/API.md)\r\n\r\n###Browser support\r\n\r\nBrowsers that [implement ECMA-262, edition 5](http://en.wikipedia.org/wiki/Ecmascript#Implementations) and later are supported.\r\n\r\nIE8 (ECMAS-262, edition 3) is supported if you include [es5-shim.js](https://github.com/kriskowal/es5-shim/blob/master/es5-shim.js) and [es5-sham.js](https://github.com/kriskowal/es5-shim/blob/master/es5-sham.js).\r\n\r\n#What are promises and why should I use them?\r\n\r\nYou should use promises to turn this:\r\n\r\n```js\r\nreadFile(\"file.json\", function(err, val) {\r\n    if( err ) {\r\n        console.error(\"unable to read file\");\r\n    }\r\n    else {\r\n        try {\r\n            val = JSON.parse(val);\r\n            console.log(val.success);\r\n        }\r\n        catch( e ) {\r\n            console.error(\"invalid json in file\");\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nInto this:\r\n\r\n```js\r\nreadFile(\"file.json\").then(JSON.parse).then(function(val) {\r\n    console.log(val.success);\r\n})\r\n.catch(SyntaxError, function(e) {\r\n    console.error(\"invalid json in file\");\r\n})\r\n.catch(function(e){\r\n    console.error(\"unable to read file\")\r\n});\r\n```\r\n\r\nActually you might notice the latter has a lot in common with code that would do the same using synchronous I/O:\r\n\r\n```js\r\ntry {\r\n    var val = JSON.parse(readFile(\"file.json\"));\r\n    console.log(val.success);\r\n}\r\n//Syntax actually not supported in JS but drives the point\r\ncatch(SyntaxError e) {\r\n    console.error(\"invalid json in file\");\r\n}\r\ncatch(Error e) {\r\n    console.error(\"unable to read file\")\r\n}\r\n```\r\n\r\nAnd that is the point - being able to have something that is a lot like `return` and `throw` in synchronous code.\r\n\r\nYou can also use promises to improve code that was written with callback helpers:\r\n\r\n\r\n```js\r\n//Copyright Plato http://stackoverflow.com/a/19385911/995876\r\n//CC BY-SA 2.5\r\nmapSeries(URLs, function (URL, done) {\r\n    var options = {};\r\n    needle.get(URL, options, function (error, response, body) {\r\n        if (error) {\r\n            return done(error)\r\n        }\r\n        try {\r\n            var ret = JSON.parse(body);\r\n            return done(null, ret);\r\n        }\r\n        catch (e) {\r\n            done(e);\r\n        }\r\n    });\r\n}, function (err, results) {\r\n    if (err) {\r\n        console.log(err)\r\n    } else {\r\n        console.log('All Needle requests successful');\r\n        // results is a 1 to 1 mapping in order of URLs > needle.body\r\n        processAndSaveAllInDB(results, function (err) {\r\n            if (err) {\r\n                return done(err)\r\n            }\r\n            console.log('All Needle requests saved');\r\n            done(null);\r\n        });\r\n    }\r\n});\r\n```\r\n\r\nIs more pleasing to the eye when done with promises:\r\n\r\n```js\r\nPromise.promisifyAll(needle);\r\nvar options = {};\r\n\r\nvar current = Promise.fulfilled();\r\nPromise.map(URLs, function(URL) {\r\n    current = current.then(function () {\r\n        return needle.getAsync(URL, options);\r\n    });\r\n    return current;\r\n}).map(function(responseAndBody){\r\n    return JSON.parse(responseAndBody[1]);\r\n}).then(function (results) {\r\n    return processAndSaveAllInDB(results);\r\n}).then(function(){\r\n    console.log('All Needle requests saved');\r\n}).catch(function (e) {\r\n    console.log(e);\r\n});\r\n```\r\n\r\nAlso promises don't just give you correspondences for synchronous features but can also be used as limited event emitters or callback aggregators.\r\n\r\nMore reading:\r\n\r\n - [Promise nuggets](http://spion.github.io/promise-nuggets/)\r\n - [Why I am switching to promises](http://spion.github.io/posts/why-i-am-switching-to-promises.html)\r\n - [What is the the point of promises](http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/#toc_1)\r\n - [Snippets for common problems](https://github.com/petkaantonov/bluebird/wiki/Snippets)\r\n - [Promise anti-patterns](https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns)\r\n\r\n#Error handling\r\n\r\nThis is a problem every promise library needs to handle in some way. Unhandled rejections/exceptions don't really have a good agreed-on asynchronous correspondence. The problem is that it is impossible to predict the future and know if a rejected promise will eventually be handled.\r\n\r\nThere are two common pragmatic attempts at solving the problem that promise libraries do.\r\n\r\nThe more popular one is to have the user explicitly communicate that they are done and any unhandled rejections should be thrown, like so:\r\n\r\n```js\r\ndownload().then(...).then(...).done();\r\n```\r\n\r\nFor handling this problem, in my opinion, this is completely unacceptable and pointless. The user must remember to explicitly call `.done` and that cannot be justified when the problem is forgetting to create an error handler in the first place.\r\n\r\nThe second approach, which is what bluebird by default takes, is to call a registered handler if a rejection is unhandled by the start of a second turn. The default handler is to write the stack trace to stderr or `console.error` in browsers. This is close to what happens with synchronous code - your code doens't work as expected and you open console and see a stack trace. Nice.\r\n\r\nOf course this is not perfect, if your code for some reason needs to swoop in and attach error handler to some promise after the promise has been hanging around a while then you will see annoying messages. In that case you can use the `.done()` method to signal that any hanging exceptions should be thrown.\r\n\r\nIf you want to override the default handler for these possibly unhandled rejections, you can pass yours like so:\r\n\r\n```js\r\nPromise.onPossiblyUnhandledRejection(function(error){\r\n    throw error;\r\n});\r\n```\r\n\r\nIf you want to also enable long stack traces, call:\r\n\r\n```js\r\nPromise.longStackTraces();\r\n```\r\n\r\nright after the library is loaded.\r\n\r\nIn node.js use the environment flag `BLUEBIRD_DEBUG`:\r\n\r\n```\r\nBLUEBIRD_DEBUG=1 node server.js\r\n```\r\n\r\nto enable long stack traces in all instances of bluebird.\r\n\r\nLong stack traces cannot be disabled after being enabled, and cannot be enabled after promises have alread been created. Long stack traces imply a substantial performance penalty, even after using every trick to optimize them.\r\n\r\nLong stack traces are enabled by default in the debug build.\r\n\r\n####Expected and unexpected errors\r\n\r\nA practical problem with Promises/A+ is that it models Javascript `try-catch` too closely for its own good. Therefore by default promises inherit `try-catch` warts such as the inability to specify the error types that the catch block is eligible for. It is an anti-pattern in every other language to use catch-all handlers because they swallow exceptions that you might not know about.\r\n\r\nNow, Javascript does have a perfectly fine and working way of creating error type hierarchies. It is still quite awkward to use them with the built-in `try-catch` however:\r\n\r\n```js\r\ntry {\r\n    //code\r\n}\r\ncatch(e) {\r\n    if( e instanceof WhatIWantError) {\r\n        //handle\r\n    }\r\n    else {\r\n        throw e;\r\n    }\r\n}\r\n```\r\n\r\nWithout such checking, unexpected errors would be silently swallowed. However, with promises, bluebird brings the future (hopefully) here now and extends the `.catch` to [accept potential error type eligibility](https://github.com/petkaantonov/bluebird/blob/master/API.md#catchfunction-errorclass-function-handler---promise).\r\n\r\nFor instance here it is expected that some evil or incompetent entity will try to crash our server from `SyntaxError` by providing syntactically invalid JSON:\r\n\r\n```js\r\ngetJSONFromSomewhere().then(function(jsonString) {\r\n    return JSON.parse(jsonString);\r\n}).then(function(object) {\r\n    console.log(\"it was valid json: \", object);\r\n}).catch(SyntaxError, function(e){\r\n    console.log(\"don't be evil\");\r\n});\r\n```\r\n\r\nHere any kind of unexpected error will automatically reported on stderr along with a stack trace because we only register a handler for the expected `SyntaxError`.\r\n\r\nOk, so, that's pretty neat. But actually not many libraries define error types and it is in fact a complete ghetto out there with ad hoc strings being attached as some arbitrary property name like `.name`, `.type`, `.code`, not having any property at all or even throwing strings as errors and so on. So how can we still listen for expected errors?\r\n\r\nBluebird defines a special error type `RejectionError` (you can get a reference from `Promise.RejectionError`). This type of error is given as rejection reason by promisified methods when\r\ntheir underlying library gives an untyped, but expected error. Primitives such as strings, and error objects that are directly created like `new Error(\"database didn't respond\")` are considered untyped.\r\n\r\nExample of such library is the node core library `fs`. So if we promisify it, we can catch just the errors we want pretty easily and have programmer errors be redirected to unhandled rejection handler so that we notice them:\r\n\r\n```js\r\n//Read more about promisification in the API Reference:\r\n//https://github.com/petkaantonov/bluebird/blob/master/API.md\r\nvar fs = Promise.promisifyAll(require(\"fs\"));\r\n\r\nfs.readFileAsync(\"myfile.json\").then(JSON.parse).then(function (json) {\r\n    console.log(\"Successful json\")\r\n}).catch(SyntaxError, function (e) {\r\n    console.error(\"file contains invalid json\");\r\n}).catch(Promise.RejectionError, function (e) {\r\n    console.error(\"unable to read file, because: \", e.message);\r\n});\r\n```\r\n\r\nThe last `catch` handler is only invoked when the `fs` module explicitly used the `err` argument convention of async callbacks to inform of an expected error. The `RejectionError` instance will contain the original error in its `.cause` property but it does have a direct copy of the `.message` and `.stack` too. In this code any unexpected error - be it in our code or the `fs` module - would not be caught by these handlers and therefore not swallowed.\r\n\r\nSince a `catch` handler typed to `Promise.RejectionError` is expected to be used very often, it has a neat shorthand:\r\n\r\n```js\r\n.error(function (e) {\r\n    console.error(\"unable to read file, because: \", e.message);\r\n});\r\n```\r\n\r\nSee [API documentation for `.error()`](https://github.com/petkaantonov/bluebird/blob/master/API.md#error-rejectedhandler----promise)\r\n\r\n<hr>\r\n\r\n####How do long stack traces differ from e.g. Q?\r\n\r\nBluebird attempts to have more elaborate traces. Consider:\r\n\r\n```js\r\nError.stackTraceLimit = 25;\r\nQ.longStackSupport = true;\r\nQ().then(function outer() {\r\n    return Q().then(function inner() {\r\n        return Q().then(function evenMoreInner() {\r\n            a.b.c.d();\r\n        }).catch(function catcher(e){\r\n            console.error(e.stack);\r\n        });\r\n    })\r\n});\r\n```\r\n\r\nYou will see\r\n\r\n    ReferenceError: a is not defined\r\n        at evenMoreInner (<anonymous>:7:13)\r\n    From previous event:\r\n        at inner (<anonymous>:6:20)\r\n\r\nCompare to:\r\n\r\n```js\r\nError.stackTraceLimit = 25;\r\nPromise.longStackTraces();\r\nPromise.fulfilled().then(function outer() {\r\n    return Promise.fulfilled().then(function inner() {\r\n        return Promise.fulfilled().then(function evenMoreInner() {\r\n            a.b.c.d()\r\n        }).catch(function catcher(e){\r\n            console.error(e.stack);\r\n        });\r\n    });\r\n});\r\n```\r\n\r\n    ReferenceError: a is not defined\r\n        at evenMoreInner (<anonymous>:7:13)\r\n    From previous event:\r\n        at inner (<anonymous>:6:36)\r\n    From previous event:\r\n        at outer (<anonymous>:5:32)\r\n    From previous event:\r\n        at <anonymous>:4:21\r\n        at Object.InjectedScript._evaluateOn (<anonymous>:572:39)\r\n        at Object.InjectedScript._evaluateAndWrap (<anonymous>:531:52)\r\n        at Object.InjectedScript.evaluate (<anonymous>:450:21)\r\n\r\n\r\nA better and more practical example of the differences can be seen in gorgikosev's [debuggability competition](https://github.com/spion/async-compare#debuggability).\r\n\r\n<hr>\r\n\r\n####Can I use long stack traces in production?\r\n\r\nProbably yes. Bluebird uses multiple innovative techniques to optimize long stack traces. Even with long stack traces, it is still way faster than similarly featured implementations that don't have long stack traces enabled and about same speed as minimal implementations. A slowdown of 4-5x is expected, not 50x.\r\n\r\nWhat techniques are used?\r\n\r\n#####V8 API second argument\r\n\r\nThis technique utilizes the [slightly under-documented](https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi#Stack_trace_collection_for_custom_exceptions) second argument of V8 `Error.captureStackTrace`. It turns out you can that the second argument can actually be used to make V8 skip all library internal stack frames [for free](https://github.com/v8/v8/blob/b5fabb9225e1eb1c20fd527b037e3f877296e52a/src/isolate.cc#L665). It only requires propagation of callers manually in library internals but this is not visible to you as user at all.\r\n\r\nWithout this technique, every promise (well not every, see second technique) created would have to waste time creating and collecting library internal frames which will just be thrown away anyway. It also allows one to use smaller stack trace limits because skipped frames are not counted towards the limit whereas with collecting everything upfront and filtering afterwards would likely have to use higher limits to get more user stack frames in.\r\n\r\n#####Sharing stack traces\r\n\r\nConsider:\r\n\r\n```js\r\nfunction getSomethingAsync(fileName) {\r\n    return readFileAsync(fileName).then(function(){\r\n        //...\r\n    }).then(function() {\r\n        //...\r\n    }).then(function() {\r\n        //...\r\n    });\r\n}\r\n```\r\n\r\nEverytime you call this function it creates 4 promises and in a straight-forward long stack traces implementation it would collect 4 almost identical stack traces. Bluebird has a light weight internal data-structure (kcnown as context stack in the source code) to help tracking when traces can be re-used and this example would only collect one trace.\r\n\r\n#####Lazy formatting\r\n\r\nAfter a stack trace has been collected on an object, one must be careful not to reference the `.stack` property until necessary. Referencing the property causes\r\nan expensive format call and the stack property is turned into a string which uses much more memory.\r\n\r\nWhat about [Q #111](https://github.com/kriskowal/q/issues/111)?\r\n\r\nLong stack traces is not inherently the problem. For example with latest Q with stack traces disabled:\r\n\r\n```js\r\nvar Q = require(\"q\");\r\n\r\n\r\nfunction test(i){\r\n    if (i <= 0){\r\n       return Q.when('done')\r\n   } else {\r\n       return Q.when(i-1).then(test)\r\n   }\r\n}\r\ntest(1000000000).then(function(output){console.log(output) });\r\n```\r\n\r\nAfter 2 minutes of running this, it will give:\r\n\r\n```js\r\nFATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory\r\n```\r\n\r\nSo the problem with this is how much absolute memory is used per promise - not whether long traces are enabled or not.\r\n\r\nFor some purpose, let's say 100000 parallel pending promises in memory at the same time is the maximum. You would then roughly use 100MB for them instead of 10MB with stack traces disabled.For comparison, just creating 100000 functions alone will use 14MB if they're closures. All numbers can be halved for 32-bit node.\r\n\r\n<hr>\r\n\r\n#Development\r\n\r\nFor development tasks such as running benchmarks or testing, you need to clone the repository and install dev-dependencies.\r\n\r\nInstall [node](http://nodejs.org/), [npm](https://npmjs.org/), and [grunt](http://gruntjs.com/).\r\n\r\n    git clone git@github.com:petkaantonov/bluebird.git\r\n    cd bluebird\r\n    npm install\r\n\r\n##Testing\r\n\r\nTo run all tests, run `grunt test`. Note that 10 processes are created to run the tests in parallel. The stdout of tests is ignored by default and everything will stop at the first failure.\r\n\r\nIndividual files can be run with `grunt test --run=filename` where `filename` is a test file name in `/test` folder or `/test/mocha` folder. The `.js` prefix is not needed. The dots for AP compliance tests are not needed, so to run `/test/mocha/2.3.3.js` for instance:\r\n\r\n    grunt test --run=233\r\n\r\nWhen trying to get a test to pass, run only that individual test file with `--verbose` to see the output from that test:\r\n\r\n    grunt test --run=233 --verbose\r\n\r\nThe reason for the unusual way of testing is because the majority of tests are from different libraries using different testing frameworks and because it takes forever to test sequentially.\r\n\r\n\r\n###Testing in browsers\r\n\r\nTo test in browsers:\r\n\r\n    cd browser\r\n    setup\r\n\r\nThen open the `index.html` in your browser. Requires bash (on windows the mingw32 that comes with git works fine too).\r\n\r\nYou may also [visit the github hosted page](http://petkaantonov.github.io/bluebird/browser/).\r\n\r\nKeep the test tab active because some tests are timing-sensitive and will fail if the browser is throttling timeouts. Chrome will do this for example when the tab is not active.\r\n\r\n##Benchmarks\r\n\r\nCurrently the most relevant benchmark is @gorkikosev's benchmark in the article [Analysis of generators and other async patterns in node](http://spion.github.io/posts/analysis-generators-and-other-async-patterns-node.html). The benchmark emulates a situation where n amount of users are making a request in parallel to execute some mixed async/sync action. The benchmark has been modified to include a warm-up phase to minimize any JITing during timed sections.\r\n\r\nYou can run the benchmark with:\r\n\r\n    bench spion\r\n\r\nWhile on the project root. Requires bash (on windows the mingw32 that comes with git works fine too).\r\n\r\nNode 0.11.2+ is required to run the generator examples.\r\n\r\nAnother benchmark to run is the [When.js benchmarks by CujoJS](https://github.com/cujojs/promise-perf-tests). The reduce and map have been modified from the original. The benchmarks also include warmup-phases.\r\n\r\n    bench cujojs\r\n\r\nWhile on the project root. Requires bash (on windows the mingw32 that comes with git works fine too).\r\n\r\n##Custom builds\r\n\r\nCustom builds for browsers are supported through a command-line utility.\r\n\r\n\r\n\r\n\r\n<table>\r\n    <caption>The following features can be disabled</caption>\r\n    <thead>\r\n        <tr>\r\n            <th>Feature(s)</th>\r\n            <th>Command line identifier</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#any---promise\"><code>.any</code></a> and <a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#promiseanyarraydynamicpromise-values---promise\"><code>Promise.any</code></a></td><td><code>any</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#callstring-propertyname--dynamic-arg---promise\"><code>.call</code></a> and <a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#getstring-propertyname---promise\"><code>.get</code></a></td><td><code>call_get</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#filterfunction-filterer---promise\"><code>.filter</code></a> and <a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#promisefilterarraydynamicpromise-values-function-filterer---promise\"><code>Promise.filter</code></a></td><td><code>filter</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#mapfunction-mapper---promise\"><code>.map</code></a> and <a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#promisemaparraydynamicpromise-values-function-mapper---promise\"><code>Promise.map</code></a></td><td><code>map</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#reducefunction-reducer--dynamic-initialvalue---promise\"><code>.reduce</code></a> and <a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#promisereducearraydynamicpromise-values-function-reducer--dynamic-initialvalue---promise\"><code>Promise.reduce</code></a></td><td><code>reduce</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#props---promise\"><code>.props</code></a> and <a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#promisepropsobjectpromise-object---promise\"><code>Promise.props</code></a></td><td><code>props</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#settle---promise\"><code>.settle</code></a> and <a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#promisesettlearraydynamicpromise-values---promise\"><code>Promise.settle</code></a></td><td><code>settle</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#someint-count---promise\"><code>.some</code></a> and <a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#promisesomearraydynamicpromise-values-int-count---promise\"><code>Promise.some</code></a></td><td><code>some</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#nodeifyfunction-callback---promise\"><code>.nodeify</code></a></td><td><code>nodeify</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutinegeneratorfunction-generatorfunction---function\"><code>Promise.coroutine</code></a> and <a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#promisespawngeneratorfunction-generatorfunction---promise\"><code>Promise.spawn</code></a></td><td><code>generators</code></td></tr>\r\n        <tr><td><a href=\"#complex-thenables\">Complex thenables</a></td><td><code>simple_thenables</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#progression\">Progression</a></td><td><code>progress</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification\">Promisification</a></td><td><code>promisify</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#cancellation\">Cancellation</a></td><td><code>cancel</code></td></tr>\r\n        <tr><td><a href=\"https://github.com/petkaantonov/bluebird/blob/master/API.md#synchronous-inspection\">Synchronous inspection</a></td><td><code>synchronous_inspection</code></td></tr>\r\n\r\n    </tbody>\r\n</table>\r\n\r\n\r\nMake sure you have cloned the repo somewhere and did `npm install` successfully.\r\n\r\nAfter that you can run:\r\n\r\n    grunt build --features=\"core simple_thenables\"\r\n\r\n\r\nThe above builds the most minimal build you can get. You can add more features separated by spaces from the above list:\r\n\r\n    grunt build --features=\"core simple_thenables filter map reduce\"\r\n\r\nThe custom build file will be found from `/js/browser/bluebird.js`. It will have a comment that lists the disabled and enabled features.\r\n\r\nNote that the build leaves the `/js/main` etc folders with same features so if you use the folder for node.js at the same time, don't forget to build\r\na full version afterwards (after having taken a copy of the bluebird.js somewhere):\r\n\r\n    grunt build\r\n\r\n####Complex thenables\r\n\r\nIn order to provide smooth interoperability experience, Promises/A+ requires supporting \"thenables\" which are promise-like objects but not trusted bluebird promises.\r\n\r\nFor example this should work:\r\n\r\n```js\r\nbluebirdPromise.then(function(){\r\n    return $.get(\"/file.php\");\r\n});\r\n```\r\n\r\nEven though the handler returns a jQuery promise, it should work as if it returned a real bluebird promise, that is, the next `.then()` will wait until the ajax\r\nrequest is complete.\r\n\r\nHowever the specification in A+ 2.x.x requires handling of many theoretical edge cases that will never be seen in practice, such as:\r\n\r\n- Trying to retrieve the `.then` property from object to see if it's a function might throw.\r\n- Retrieving `.then` property multiple times from an object might return different result every time, or might be deleted after some time\r\n- Calling the `.then` property of an object before necessary (just in time thenables) might cause problems\r\n- etc.\r\n\r\nWhat you want in a browser is pretty much that the `return $.get` line works. Can you imagine jQuery defining a getter on `.then` property that throws?\r\n\r\nHandling such cases requires a lot of code in bluebird. You can use the `simple_thenables` feature which matches what other libraries such as Q are doing.\r\n\r\n<hr>\r\n\r\n##What is the sync build?\r\n\r\nYou may now use sync build by:\r\n\r\n    var Promise = require(\"bluebird/zalgo\");\r\n\r\nThe sync build is provided to see how forced asynchronity affects benchmarks. It should not be used in real code due to the implied hazards.\r\n\r\nThe normal async build gives Promises/A+ guarantees about asynchronous resolution of promises. Some people think this affects performance or just plain love their code having a possibility\r\nof stack overflow errors and non-deterministic behavior.\r\n\r\nThe sync build skips the async call trampoline completely, e.g code like:\r\n\r\n    async.invoke( this.fn, this, val );\r\n\r\nAppears as this in the sync build:\r\n\r\n    this.fn(val);\r\n\r\nThis should pressure the CPU slightly less and thus the sync build should perform better. Indeed it does, but only marginally. The biggest performance boosts are from writing efficient Javascript, not from compromising determinism.\r\n\r\nNote that while some benchmarks are waiting for the next event tick, the CPU is actually not in use during that time. So the resulting benchmark result is not completely accurate because on node.js you only care about how much the CPU is taxed. Any time spent on CPU is time the whole process (or server) is paralyzed. And it is not graceful like it would be with threads.\r\n\r\n\r\n```js\r\nvar cache = new Map(); //ES6 Map or DataStructures/Map or whatever...\r\nfunction getResult(url) {\r\n    var resolver = Promise.pending();\r\n    if (cache.has(url)) {\r\n        resolver.fulfill(cache.get(url));\r\n    }\r\n    else {\r\n        http.get(url, function(err, content) {\r\n            if (err) resolver.reject(err);\r\n            else {\r\n                cache.set(url, content);\r\n                resolver.fulfill(content);\r\n            }\r\n        });\r\n    }\r\n    return resolver.promise;\r\n}\r\n\r\n\r\n\r\n//The result of console.log is truly random without async guarantees\r\nfunction guessWhatItPrints( url ) {\r\n    var i = 3;\r\n    getResult(url).then(function(){\r\n        i = 4;\r\n    });\r\n    console.log(i);\r\n}\r\n```\r\n\r\n#Optimization guide\r\n\r\ntodo\r\n\r\n#License\r\n\r\nCopyright (c) 2013 Petka Antonov\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:</p>\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n",
  "_id": "bluebird@0.9.7-0",
  "dist": {
    "shasum": "fcc2f182b7300ee2ad00f435094b1ace8d6bff60"
  },
  "_from": "bluebird@",
  "_resolved": "https://registry.npmjs.org/bluebird/-/bluebird-0.9.7-0.tgz"
}
