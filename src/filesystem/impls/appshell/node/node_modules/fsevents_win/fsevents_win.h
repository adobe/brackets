// 

#include <v8.h>
#include <uv.h>
#include <node.h>

#define MAXPATH 1024
#define READ_DIRECTORY_CHANGES_BUFSIZE  8192

using namespace v8;

class CAsyncDirWatchInfo
{
public:
	// struct tracking ReadDirectoryChangesW() changes
	struct sEntry {
		LPWSTR m_lpwszFilename;
		DWORD m_dwAction;
		struct sEntry *m_pPrevious, *m_pNext;

		sEntry(LPWSTR lpwszFilename, int iFilenameLen, DWORD dwAction);
		~sEntry();
	};
	typedef sEntry* LPENTRY;

public:
	CAsyncDirWatchInfo();
	~CAsyncDirWatchInfo();

	void Enqueue(LPENTRY lpEntry);
	LPENTRY Dequeue();

protected:
	struct sEntry *m_pHead, *m_pTail;		// pointer to head and tail of queue of file notification changes
	HANDLE m_hMutex;						// mutex synchronizing access to queue
};

class NodeFSEvents : public node::ObjectWrap
{
public:
	NodeFSEvents(const char *lpszPath);
	~NodeFSEvents();

	// JS wrapper methods
	static void Initialize(Handle<Object> target);
	static Handle<Value> Shutdown(const Arguments& args);
	static Handle<Value> New(const Arguments& args);

protected:
	// file watching methods
	void Startup(const char *lpszPath);
	void Shutdown();
public:
	static DWORD WINAPI Run(LPVOID lpData);
	static void Callback(uv_async_t *handle, int status);

protected:
	WCHAR m_wszPathName[MAXPATH + 1];		// root path to watch
	CAsyncDirWatchInfo *m_pWatchInfo;		// queue of file notification changes
	PFILE_NOTIFY_INFORMATION m_lpBuffer;	// buffer for watched file notification changes
	HANDLE m_hAsyncDir;						// handle to watched parent folder
	HANDLE m_hIoCPort;						// handle to I/O completion port
	OVERLAPPED m_Overlapped;				// handle to overlapped I/O
	uv_async_t m_uvaWatcher;				// handle to uv watch
	HANDLE m_hThread;						// handle to watcher thread
};
